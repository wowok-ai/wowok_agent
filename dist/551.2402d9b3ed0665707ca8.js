"use strict";(this.webpackChunkwowok_agent=this.webpackChunkwowok_agent||[]).push([[551],{43:(e,t,r)=>{function i(e){const t=e.startsWith("0x")?e.slice(2):e,r=t.length%2==0?t:`0${t}}`,i=r.match(/.{2}/g)?.map((e=>parseInt(e,16)))??[];return Uint8Array.from(i)}function n(e){return e.reduce(((e,t)=>e+t.toString(16).padStart(2,"0")),"")}r.d(t,{J:()=>n,i:()=>i})},8551:(e,t,r)=>{r.d(t,{r8:()=>z,PN:()=>I});var i=r(9725);const n=e=>i.encode(e),s=e=>i.decode(e);function a(e){return Uint8Array.from(atob(e),(e=>e.charCodeAt(0)))}const o=8192;function h(e){if(e.length<o)return btoa(String.fromCharCode(...e));let t="";for(var r=0;r<e.length;r+=o){const i=e.slice(r,r+o);t+=String.fromCharCode(...i)}return btoa(t)}var c=r(43);class u{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer)}shift(e){return this.bytePosition+=e,this}read8(){let e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){let e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){let e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){let e=this.read32(),t=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+t).toString(10)}read128(){let e=BigInt(this.read64()),t=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+t).toString(10)}read256(){let e=BigInt(this.read128()),t=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+t).toString(10)}readBytes(e){let t=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,t,e);return this.shift(e),r}readULEB(){let e=this.bytePosition+this.dataView.byteOffset,t=new Uint8Array(this.dataView.buffer,e),{value:r,length:i}=function(e){let t=0,r=0,i=0;for(;;){let n=e[i];if(i+=1,t|=(127&n)<<r,!(128&n))break;r+=7}return{value:t,length:i}}(t);return this.shift(i),r}readVec(e){let t=this.readULEB(),r=[];for(let i=0;i<t;i++)r.push(e(this,i,t));return r}}class p{constructor({size:e=1024,maxSize:t,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=t||e,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const t=this.bytePosition+e;if(t>this.size){const e=Math.min(this.maxSize,this.size+this.allocateSize);if(t>e)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${t}`);this.size=e;const r=new ArrayBuffer(this.size);new Uint8Array(r).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(r)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return f(BigInt(e),8).forEach((e=>this.write8(e))),this}write128(e){return f(BigInt(e),16).forEach((e=>this.write8(e))),this}write256(e){return f(BigInt(e),32).forEach((e=>this.write8(e))),this}writeULEB(e){return function(e){let t=[],r=0;if(0===e)return[0];for(;e>0;)t[r]=127&e,(e>>=7)&&(t[r]|=128),r+=1;return t}(e).forEach((e=>this.write8(e))),this}writeVec(e,t){return this.writeULEB(e.length),Array.from(e).forEach(((r,i)=>t(this,r,i,e.length))),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return function(e,t){switch(t){case"base58":return n(e);case"base64":return h(e);case"hex":return(0,c.J)(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(this.toBytes(),e)}}function f(e,t){let r=new Uint8Array(t),i=0;for(;e>0;)r[i]=Number(e%BigInt(256)),e/=BigInt(256),i+=1;return r}var d,l,y,w,g=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},m=(e,t,r)=>(g(e,t,"read from private field"),r?r.call(e):t.get(e)),T=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},b=(e,t,r,i)=>(g(e,t,"write to private field"),i?i.call(e,r):t.set(e,r),r);const S=class{constructor(e){T(this,d,void 0),T(this,l,void 0),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),b(this,d,e.write),b(this,l,e.serialize??((e,t)=>{const r=new p({size:this.serializedSize(e)??void 0,...t});return m(this,d).call(this,e,r),r.toBytes()})),this.validate=e.validate??(()=>{})}write(e,t){this.validate(e),m(this,d).call(this,e,t)}serialize(e,t){return this.validate(e),new U(this,m(this,l).call(this,e,t))}parse(e){const t=new u(e);return this.read(t)}transform({name:e,input:t,output:r}){return new S({name:e??this.name,read:e=>r(this.read(e)),write:(e,r)=>m(this,d).call(this,t(e),r),serializedSize:e=>this.serializedSize(t(e)),serialize:(e,r)=>m(this,l).call(this,t(e),r),validate:e=>this.validate(t(e))})}};let E=S;d=new WeakMap,l=new WeakMap;const v=Symbol.for("@mysten/serialized-bcs");class U{constructor(e,t){T(this,y,void 0),T(this,w,void 0),b(this,y,e),b(this,w,t)}get[v](){return!0}toBytes(){return m(this,w)}toHex(){return(0,c.J)(m(this,w))}toBase64(){return h(m(this,w))}toBase58(){return n(m(this,w))}parse(){return m(this,y).parse(m(this,w))}}y=new WeakMap,w=new WeakMap;const A=32,$=class{constructor(e){if(this.types=new Map,this.counter=0,e instanceof $)return this.schema=e.schema,void(this.types=new Map(e.types));if(this.schema=e,this.registerAddressType($.ADDRESS,e.addressLength,e.addressEncoding),this.registerVectorType(e.vectorType),e.types&&e.types.structs)for(let t of Object.keys(e.types.structs))this.registerStructType(t,e.types.structs[t]);if(e.types&&e.types.enums)for(let t of Object.keys(e.types.enums))this.registerEnumType(t,e.types.enums[t]);if(e.types&&e.types.aliases)for(let t of Object.keys(e.types.aliases))this.registerAlias(t,e.types.aliases[t]);var t;!1!==e.withPrimitives&&((t=this).registerType(z.U8,(function(e,t){return e.write8(t)}),(function(e){return e.read8()}),(e=>e<256)),t.registerType(z.U16,(function(e,t){return e.write16(t)}),(function(e){return e.read16()}),(e=>e<65536)),t.registerType(z.U32,(function(e,t){return e.write32(t)}),(function(e){return e.read32()}),(e=>e<=4294967296n)),t.registerType(z.U64,(function(e,t){return e.write64(t)}),(function(e){return e.read64()})),t.registerType(z.U128,(function(e,t){return e.write128(t)}),(function(e){return e.read128()})),t.registerType(z.U256,(function(e,t){return e.write256(t)}),(function(e){return e.read256()})),t.registerType(z.BOOL,(function(e,t){return e.write8(t)}),(function(e){return"1"===e.read8().toString(10)})),t.registerType(z.STRING,(function(e,t){return e.writeVec(Array.from(t),((e,t)=>e.write8(t.charCodeAt(0))))}),(function(e){return e.readVec((e=>e.read8())).map((e=>String.fromCharCode(Number(e)))).join("")}),(e=>!0)),t.registerType(z.HEX,(function(e,t){return e.writeVec(Array.from((0,c.i)(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return(0,c.J)(new Uint8Array(t))})),t.registerType(z.BASE58,(function(e,t){return e.writeVec(Array.from(s(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return n(new Uint8Array(t))})),t.registerType(z.BASE64,(function(e,t){return e.writeVec(Array.from(a(t)),((e,t)=>e.write8(t)))}),(function(e){let t=e.readVec((e=>e.read8()));return h(new Uint8Array(t))})))}tempKey(){return"bcs-struct-"+ ++this.counter}ser(e,t,r){if("string"==typeof e||Array.isArray(e)){const{name:i,params:n}=this.parseTypeName(e);return this.getTypeInterface(i).encode(this,t,r,n)}if("object"==typeof e){const i=this.tempKey();return new $(this).registerStructType(i,e).ser(i,t,r)}throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(e)}`)}de(e,t,r){if("string"==typeof t){if(!r)throw new Error("To pass a string to `bcs.de`, specify encoding");t=function(e,t){switch(t){case"base58":return s(e);case"base64":return a(e);case"hex":return(0,c.i)(e);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}(t,r)}if("string"==typeof e||Array.isArray(e)){const{name:r,params:i}=this.parseTypeName(e);return this.getTypeInterface(r).decode(this,t,i)}if("object"==typeof e){const i=new $(this),n=this.tempKey();return i.registerStructType(n,e).de(n,t,r)}throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(e)}`)}hasType(e){return this.types.has(e)}registerAlias(e,t){return this.types.set(e,t),this}registerType(e,t,r,i=()=>!0){const{name:n,params:s}=this.parseTypeName(e);return this.types.set(n,{encode(e,t,r,i){const n=s.reduce(((e,t,r)=>Object.assign(e,{[t]:i[r]})),{});return this._encodeRaw.call(e,new p(r),t,i,n)},decode(e,t,r){const i=s.reduce(((e,t,i)=>Object.assign(e,{[t]:r[i]})),{});return this._decodeRaw.call(e,new u(t),r,i)},_encodeRaw(e,r,s,a){if(i(r))return t.call(this,e,r,s,a);throw new Error(`Validation failed for type ${n}, data: ${r}`)},_decodeRaw(e,t,i){return r.call(this,e,t,i)}}),this}registerBcsType(e,t){return this.registerType(e,((e,r,i)=>{const n=i.map((e=>new E({name:String(e),write:(t,r)=>{const{name:n,params:s}=this.parseTypeName(e),a=this.getTypeInterface(n),o=s.reduce(((e,t,r)=>Object.assign(e,{[t]:i[r]})),{});return a._encodeRaw.call(this,r,t,s,o)},read:()=>{throw new Error("Not implemented")}})));return t(...n).write(r,e),e}),((e,r)=>{const i=r.map((e=>new E({name:String(e),write:(e,t)=>{throw new Error("Not implemented")},read:t=>{const{name:i,params:n}=this.parseTypeName(e),s=this.getTypeInterface(i),a=n.reduce(((e,t,i)=>Object.assign(e,{[t]:r[i]})),{});return s._decodeRaw.call(this,t,n,a)}})));return t(...i).read(e)})),this}registerAddressType(e,t,r="hex"){switch(r){case"base64":return this.registerType(e,(function(e,t){return a(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return h(e.readBytes(t))}));case"hex":return this.registerType(e,(function(e,t){return(0,c.i)(t).reduce(((e,t)=>e.write8(t)),e)}),(function(e){return(0,c.J)(e.readBytes(t))}));default:throw new Error("Unsupported encoding! Use either hex or base64")}}registerVectorType(e){let{name:t,params:r}=this.parseTypeName(e);if(r.length>1)throw new Error("Vector can have only one type parameter; got "+t);return this.registerType(e,(function(t,r,i,n){return t.writeVec(r,((t,r)=>{let s=i[0];if(!s)throw new Error(`Incorrect number of type parameters passed a to vector '${e}'`);let{name:a,params:o}=this.parseTypeName(s);if(this.hasType(a))return this.getTypeInterface(a)._encodeRaw.call(this,t,r,o,n);if(!(a in n))throw new Error(`Unable to find a matching type definition for ${a} in vector; make sure you passed a generic`);let{name:h,params:c}=this.parseTypeName(n[a]);return this.getTypeInterface(h)._encodeRaw.call(this,t,r,c,n)}))}),(function(t,r,i){return t.readVec((t=>{let n=r[0];if(!n)throw new Error(`Incorrect number of type parameters passed to a vector '${e}'`);let{name:s,params:a}=this.parseTypeName(n);if(this.hasType(s))return this.getTypeInterface(s)._decodeRaw.call(this,t,a,i);if(!(s in i))throw new Error(`Unable to find a matching type definition for ${s} in vector; make sure you passed a generic`);let{name:o,params:h}=this.parseTypeName(i[s]);return this.getTypeInterface(o)._decodeRaw.call(this,t,h,i)}))}))}registerStructType(e,t){for(let e in t){let r=this.tempKey(),i=t[e];Array.isArray(i)||"string"==typeof i||(t[e]=r,this.registerStructType(r,i))}let r=Object.freeze(t),i=Object.keys(r),{name:n,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t||t.constructor!==Object)throw new Error(`Expected ${n} to be an Object, got: ${t}`);if(a.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${a.length}`);for(let h of i){if(!(h in t))throw new Error(`Struct ${n} requires field ${h}:${r[h]}`);const{name:i,params:c}=this.parseTypeName(r[h]);if(s.includes(i)){const r=s.indexOf(i);let{name:c,params:u}=this.parseTypeName(a[r]);if(this.hasType(c)){this.getTypeInterface(c)._encodeRaw.call(this,e,t[h],u,o);continue}if(!(c in o))throw new Error(`Unable to find a matching type definition for ${c} in ${n}; make sure you passed a generic`);let{name:p,params:f}=this.parseTypeName(o[c]);this.getTypeInterface(p)._encodeRaw.call(this,e,t[h],f,o)}else this.getTypeInterface(i)._encodeRaw.call(this,e,t[h],c,o)}return e}),(function(e,t,a){if(t.length!==s.length)throw new Error(`Incorrect number of generic parameters passed; expected: ${s.length}, got: ${t.length}`);let o={};for(let h of i){const{name:i,params:c}=this.parseTypeName(r[h]);if(s.includes(i)){const r=s.indexOf(i);let{name:c,params:u}=this.parseTypeName(t[r]);if(this.hasType(c)){o[h]=this.getTypeInterface(c)._decodeRaw.call(this,e,u,a);continue}if(!(c in a))throw new Error(`Unable to find a matching type definition for ${c} in ${n}; make sure you passed a generic`);let{name:p,params:f}=this.parseTypeName(a[c]);o[h]=this.getTypeInterface(p)._decodeRaw.call(this,e,f,a)}else o[h]=this.getTypeInterface(i)._decodeRaw.call(this,e,c,a)}return o}))}registerEnumType(e,t){for(let e in t){let r=this.tempKey(),i=t[e];null===i||Array.isArray(i)||"string"==typeof i||(t[e]=r,this.registerStructType(r,i))}let r=Object.freeze(t),i=Object.keys(r),{name:n,params:s}=this.parseTypeName(e);return this.registerType(e,(function(e,t,a,o){if(!t)throw new Error(`Unable to write enum "${n}", missing data.\nReceived: "${t}"`);if("object"!=typeof t)throw new Error(`Incorrect data passed into enum "${n}", expected object with properties: "${i.join(" | ")}".\nReceived: "${JSON.stringify(t)}"`);let h=Object.keys(t)[0];if(void 0===h)throw new Error(`Empty object passed as invariant of the enum "${n}"`);let c=i.indexOf(h);if(-1===c)throw new Error(`Unknown invariant of the enum "${n}", allowed values: "${i.join(" | ")}"; received "${h}"`);let u=i[c],p=r[u];if(e.write8(c),null===p)return e;let f=s.indexOf(p),d=-1===f?p:a[f];{let{name:r,params:i}=this.parseTypeName(d);return this.getTypeInterface(r)._encodeRaw.call(this,e,t[h],i,o)}}),(function(e,t,a){let o=e.readULEB(),h=i[o],c=r[h];if(-1===o)throw new Error(`Decoding type mismatch, expected enum "${n}" invariant index, received "${o}"`);if(null===c)return{[h]:!0};let u=s.indexOf(c),p=-1===u?c:t[u];{let{name:t,params:r}=this.parseTypeName(p);return{[h]:this.getTypeInterface(t)._decodeRaw.call(this,e,r,a)}}}))}getTypeInterface(e){let t=this.types.get(e);if("string"==typeof t){let e=[];for(;"string"==typeof t;){if(e.includes(t))throw new Error(`Recursive definition found: ${e.join(" -> ")} -> ${t}`);e.push(t),t=this.types.get(t)}}if(void 0===t)throw new Error(`Type ${e} is not registered`);return t}parseTypeName(e){if(Array.isArray(e)){let[t,...r]=e;return{name:t,params:r}}if("string"!=typeof e)throw new Error(`Illegal type passed as a name of the type: ${e}`);let[t,r]=this.schema.genericSeparators||["<",">"],i=e.indexOf(t),n=Array.from(e).reverse().indexOf(r);if(-1===i&&-1===n)return{name:e,params:[]};if(-1===i||-1===n)throw new Error(`Unclosed generic in name '${e}'`);let s=e.slice(0,i),a=function(e,t=["<",">"]){const[r,i]=t,n=[];let s="",a=0;for(let t=0;t<e.length;t++){const o=e[t];o===r&&a++,o===i&&a--,0!==a||","!==o?s+=o:(n.push(s.trim()),s="")}return n.push(s.trim()),n}(e.slice(i+1,e.length-n-1),this.schema.genericSeparators);return{name:s,params:a}}};let z=$;function I(){return{genericSeparators:["<",">"],vectorType:"vector",addressLength:A,addressEncoding:"hex"}}z.U8="u8",z.U16="u16",z.U32="u32",z.U64="u64",z.U128="u128",z.U256="u256",z.BOOL="bool",z.VECTOR="vector",z.ADDRESS="address",z.STRING="string",z.HEX="hex-string",z.BASE58="base58-string",z.BASE64="base64-string"}}]);